[TOC]

# 秒杀web应用部署运行接口及页面效果
## 秒杀列表页
- 秒杀列表页API <br>
http://localhost:8080/seckill/list<br>
- 秒杀列表页效果
![秒杀列表页效果](https://github.com/greensure/WebAppDemo/blob/master/seckill/screenshots/%E7%A7%92%E6%9D%80%E5%88%97%E8%A1%A8%E9%A1%B5%E6%95%88%E6%9E%9C.png)

- 详情页API
http://localhost:8080/seckill/1000/detail

- 详情页效果
![秒杀列表页效果1](0BE5D8F45B484CE79591C661AB25DC66)

![秒杀列表页效果2](FB44724CDDB54AD3BD0CC25C6AC5312F)

# 秒杀系统业务流程
![业务流程](8D932D31964A422289B10E028F23DFE4)

# 秒杀系统的业务核心

## 库存的处理
![库存的处理](97312E43593A433A9F4C85DCA7228BDF)

## 记录秒杀购买行为
![购买行为](A9403B66CE394C35A20358D7DC342E49)

# Mysql实现秒杀难点分析
秒杀的难点是如何高效的处理竞争？<br>
![Mysql实现秒杀难点分析](2A677B9A390043A780FD9289351DC392)

## 行级锁问题
![Mysql实现秒杀难点分析2](5E35E63A8DFD4E85AEE33E2C18AA1BE9)

# 秒杀功能
## 1、秒杀接口暴露
## 2、执行秒杀
## 3、相关查询

# 秒杀系统的技术栈
## 该项目技术栈
- 后端<br>
关系型数据库：Mysql;<br>
ORM: Mybatis;<br>
项目搭建框架：maven + Spring + SpringMVC;<br>
- 测试<br>
接口测试工具：PostMan；<br>
单元测试：Junit4;<br>
- 日志<br>
日志：logback;<br>

- 前端：<br>
Restful接口；<br>
bootstrap + jquery；<br>

## 使用注解控制方法的优点
1.开发团队约定明确标注事务方法的风格；<br>
2.保证事务方法的执行时间尽可能短，不要穿插其他的网络操作:RPC/HTTP请求、或移动到事务方法外部；<br>
3.不是所有的方法都需要事务，如果只有一条修改操作，只读操作不需要事务控制。<br>

## 包名简介
entity包：业务数据的封装；
Enum包：常量信息，把数据字典放到枚举中<br>
dao包：数据库持久化；<br>
dto包：数据传输层，和entity类似，用于存放表示数据的类型， 用来关注外部和servic之间的数据传递；<br>
exception包：自定义异常类,当出现异常时要提醒接口使用方，可能会输出什么样的异常——自定义异常类型；<br>
注：JAVA异常分为编译时异常、运行期异常,  Spring声明式事务只接收运行期异常回滚策略，当抛出非运行期异常的时候，实际上是不做回滚的；<br>

## Sprin IOC是啥？
控制反转（Inversion of Control）:   就是依赖倒置原则的一种代码设计的思路。具体采用的方法就是所谓的依赖注入（Dependency Injection）。

## 为什么用 IOC
1、对象创建统一托管；<br>
2、规范的生命周期管理；<br>
3、灵活的依赖注入；<br>
4、一致的获取对象；<br>

## Spring-IOC注入方式和场景
![Spring-IOC注入方式和场景](60561AEB9DB145AD85E05F0556D32456)

该项目使用XML配置、package-scan、Annotation注解；<br>

## 什么是声明式事务 ?
在spring中有声明式事务的概念。我们可以利用xml配置文件的方法，或者使用Annotation的方法，将需要加入事务控制的方法声明一下就可以了。这样spring容器就会自动的扫描声明过的方法，自动的加入事务的开启、提交、回滚 操作。我们可以更加专注于我们的业务逻辑。这就是声明式事务的概念；

## 声明式事务的使用方式
![声明式事务的使用方式](69E61DAA730E4FBCAFB03D5680A782CF)

## 什么时候回滚事务
1、抛出运行期异常（RuntimeException）;<br>
2、小心不当的try-catch;<br>

## SpringMVC运行流程
![SpringMVC运行流程](D733B6206CA4496687F720F6D1C083CE)


## HTTP请求地址映射原理
![HTTP请求地址映射原理](315C9E51F9F74C8ABCF4533CC9F9EC5A)

## 注解映射技巧
![注解映射技巧](25A7D87C5102427EBE7513A38E0B8A2B)

## 请求方法细节处理
1、请求参数绑定；<br>
2、请求方式限制；<br>
3、请求转发和重定向；<br>
4、数据模型赋值；<br>
5、返回json数据；<br>
6、cookie访问；<br>


## 什么是Restful
一种优雅的URI表达方式；<br>
资源的状态和状态转移；<br>

## redirect和forwad区别
直接转发方式（Forward），客户端和浏览器只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。<br>

间接转发方式（Redirect）实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。<br>

通俗的解释：<br>
forwad（直接转发）就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；
redirect（间接转发）就相当于："A找B借钱，B说没有，让A去找C借"。


# 怎么站在用户角度去设计？
初学者常犯的一个问题，总是去关注细节，关注这个方法去怎么实现，这样设计出来的接口往往非常的冗余，真的到了去开发web，别人去用你的接口的时候会感到非常的不便，我们在设计接口的时候应该站在使用者的角度去设计，可以从以下三个方面去着手：<br>
## （1）方法定义的粒度
方法定义的粒度应该明确，比如“秒杀”，肯定要有接口，执行秒杀，传入执行秒杀所需要的一些参数，不应该去关注秒杀怎么去减库存、怎么去添加用户的购买行为，这样的一些信息对我们来说其实是实现，我们应该站在使用者角度，使用者怎么方便，怎么让使用者友好的去调用接口；

## （2）参数
参数是越简练，越直接越好，而不是随便给他一个map放一些参数 或者封装一个非常庞大的参数列表，让别人去传递参数；

## （3）返回类型（return类型/异常）
return的类型一定要友好，而不是return一个map，然后里面是随便放置key-value这样的数，或者是return了一个entity（且这个entity数据不够）；一个方法的退出可以正常的返回，还可以抛出异常，这个异常有的时候不是坏事情，有时是业务允许的；

# 前端交互采用的技术
![前端交互采用的技术](2D79B2FF706B4ED2BB41094D75E1569E)

# 前端页面交互流程
## 列表页流程逻辑
![前端页面流程](5471D8A47AFE4EC7A51FC473464C9BF2)

## 详情页流程逻辑
![详情页流程逻辑](AECC24330BD94D0E874BA757FB83487D)

# 秒杀系统高并发优化
## 秒杀系统高并发接口
>红色部分代表可能出现高并发的点，绿色部分代表不会出现高并发的点；<br>

![秒杀系统高并发优化分析](58B9594EBE8942C99C29D70496595867)

## 为什么要单独获得系统时间？
 > 单独获得系统时间为高并发优化做铺垫；

为什么说单独获得系统时间为高并发优化做铺垫呢？<br>
在秒杀未开始前,用户看到感兴趣的商品时，会不停的刷新详情页，刷新页面的时候，系统的详情页会部署到CDN节点上，CDN会包括Detail页面，还会把做Detail页面静态化处理，静态化处理之后也就是说用户访问的那些html已经不再秒杀系统上了，在CDN的节点上，详情页中会有很多获取静态资源的请求，例如加载CSS，javascript, jquery插件，这些静态资源也会部署到CDN上面，换句话说访问Detail页面或访问静态资源是不用返回秒杀系统的，此时就拿不到系统的时间了，所以单独做一个请求来获取当前服务器的系统时间。除了这些静态资源、静态化的详情页，其他的请求，比如获取秒杀地址、执行秒杀都是对应到秒杀系统上来；

# CDN的理解
1、CDN(内容分发网络)加速用户获取数据的系统；<br>
2、部署在离用户最近的网络节点上<br>
3、命中CDN不需要访问后端服务器<br>
4、互联网公司自己搭建或租用<br>

>对CDN理解的详细解释：<br>
CDN: 内容分发服务，本身是加速用户获取数据的系统。获取的数据可以是静态资源、动态资源，取决于推送策略，市面上大部分的视频加速完全依赖于CDN, 例如优酷、搜酷视频等视频资源绑定在CDN上用了加速用户获取视频资源数据的速度；
CDN运营商的部署一般都是在离用户最近的网络节点上，用户通过运营商（例如接入电信、长城等），用户想上网的时候通过这些运营商的接口去访问他最近程序的网络上的节点，通过程序网再去跳到主干网，主干网是根据对应的IP找到对应资源访问资源所在的服务器，当然很大一部分已经在上一层的节点上CDN已经找到了对应的内容，他也就不用再往后查找，直接返回对应的内容；<br>

命中了CDN之后程序是不需要访问后端的服务器的；<br>
互联网公司一般都会自己建一条CDN或者租用，大的互联网公司例如BAT会用自己建的CDN集群，像一些小的互联网公司会选择租用，例如租用电信的CDN、网通的CDN.<br>

按照上述内容，获取详情页的HTML, css, javascript的一些信息是不用返回秒杀系统服务器的。<br>
那么引发一个问题，若每一次调用页面的时候都获取系统时间，而这个系统时间不会缓存到CDN上，而直接调用服务器，直接到服务器上去拿系统时间，那么获取系统时间是否要优化呢？<br>
获取系统时间不用优化；<br>
>获取系统时间不用优化的原因：<br>
因为java在访问一次内存，大概需要10ns，1s=10亿ns, 那么我们访问系统时间，本质上也就是new了一个时间对象，然后返回队列，这个操作若不考虑GC的影响的化，1s中可以出1亿次，所以这个操作可以不用优化，因为完全没有后台返回。

另一个高并发的点：获取秒杀地址的分析；<br>
首先获取秒杀地址无法使用CDN的, 原因：CDN是和请求对应的资源不一 一变化的，比如静态资源javascript是用在浏览器中执行，内容是不变的，一个URL对应的是不变的结果，但是秒杀地址的数据返回是在变化的，随着时间，一开始没有开启秒杀，随着时间推移已经开启秒杀，再往后，秒杀已经关闭了，这些都是秒杀地址给我们返回的数据，他不适合放在CDN缓存，但是适合放在服务器端缓存，例如Redis , 这样的Redis服务器端缓存可以抗很高的QPS, 那么官方给出来的数据大概是1秒中10万个QBS,10万也是一个很高的数据量，Redis还可以做集群，集群化之后可以抗百万的QPS.<br>

# 为什么要做到后端的缓存呢？
因为后端的缓存可以用我们的业务系统来控制，比如我们先返回数据库拿到秒杀的数据，然后把他放到Redis缓存里面，当下一次访问的时候，直接去缓存里面查找，缓存里边有就直接返回，而不用访问数据了；
<br>

# 秒杀地址接口分析
- 无法使用CDN缓存；
- 适合服务端缓存：Redis等；
- 一致性维护成本低；
<br>

一致性维护成本底：当秒杀的东西或秒杀对象改变后，可以修改数据库，同时可以改下缓存或者干脆不改，等超时之后再改；<br>

# 秒杀地址接口优化
![秒杀地址接口优化](6914206B1DE04A198E2E6F7983AEF357)

<br>
请求地址要拿到秒杀对象，他会先返回Redis, 然后再返回Mysql， 如果没有的话，返回Mysql;<br> 对于同一个秒杀的对象来说，下一次访问的时候可以直接从Redis缓存中获取到 ；<br>
一致性维护很简单：比如缓存半小时，半小时之后，Redis的秒杀对象就会超时，超时之后呢直接穿梭到Mysql, 或者是当Mysql更新的时候，主动更新下Redis, 这样也非常的方便；<br>
换句话说，秒杀地址这样的接口，他本质上就是拿了一个秒杀对象然后判断当前的信用时间、秒杀的开始时间，结束时间来做判断，来决定返回数据;<br> 数据是什么样的，要不要暴露秒杀地址。<br>

# 秒杀操作优化分析
- 无法使用CDN缓存；
- 后端缓存困难：库存问题；
- 一行数据竞争：热点商品；

<br>
秒杀操作的优化分析阐述：<br>
该操作没法发CDN缓存，因为CDN不可能把最核心的内容进行缓存，大部分的写操作和最核心的数据请求一般没办法使用CDN, 后端的缓存比较困难；<br>

>为什么后端的缓存比较困难？<br>
库存问题，如果我访问Redis命中了我直接返回，那么其他用户也可能访问Redis命中了返回，此时就会有库存的问题，所以不会在缓存里去减库存 ，这样会产生不一致问题，所以要通过Mysql的事务来保证事务的一致性。<br>

一行数据竞争即热点商品问题：<br> 一瞬间会有大量的用户参与进来，去点击按钮进行秒杀，那么也就是在一行数据里产生竞争，这个会对Mysql里表中的那一行数据产生大量的update减库存竞争，这也是我们分析到的秒杀操作比较困难的一个点 。

# 秒杀的其他方案分析
![其他方案分析](F19B872D2A204CC899E4177E46A8EAA3)
<br>
分析这样架构的问题及维护点：<br>
当执行秒杀的时候，一般的系统是这样做的，他做一个原子计数器，这个原子计数器可以通过一些Redis或NoSQL来去实现，这个原子计数器就是记录商品的库存，当一个用户进来执行秒杀的时候会减库存，即减原子计数器，他是一个保证原子性，当减库存减原子计数器成功之后，他会去记录一个行为，比如谁去减了这个库存，记录下来之后作为一个消息放到分布式的MQ中 , 这个分布式的MQ就是消息队列，常用的消息队列例如RabitMQ, 阿里巴巴自己实现的非常高效的RocketMQ(支持事务，更强大), j2ee官方版本的ActiveMQ, Linkedin开发的kafka等，这些都是分布式 MQ;<br>

>把消息放在MQ中，后端的服务会去消费这个消息并落地，落地到MYSQL中，例如会记录谁买了商品；  <br>

该架构的优点：<br>
这个架构可以抗住非常高的并发，如果他的Redis做成集群的话，理论上来说做成100个Redis实例，每台10万，可以抗很高的并发，而且分布式MQ, 例如RocketMQ的单个MQ可以支持 几十万的KBS, 所以这也是腾讯、阿里巴巴他们做的解决方案里面的一个常用的解决方案，这个方案也有痛点；<br>

# 秒杀的其他方案的缺点分析
- 运维成本和稳定性：NoSQL, MQ;
- 开发成本：数据库一致性，回滚方案等；
- 幂等性难保证：重复秒杀问题
- 不适合新手的架构

<br>

>运维成本和稳定性：<br>
NoSQL, MQ是分布式服务，就像Mysql一样都是部署在另外一些机器上，此处NoSQL就是Redis ，MQ（RabitMQ，RocketMQ），NoSQL远远没有Mysql稳定，也就是说需要一个非常强大的运维团队来去支撑这些分布式组件的稳定性; <br>
还要有一些开发成本在里面，比如工程师要对这些组件非常的熟悉，熟悉他们的数据一致性模型，以及了解自己的逻辑应该怎么处理、回滚，比如当减库存失败了，怎么去回滚，当减完库存之后发现访问MQ超时了怎么去回滚，这些都需要手动去实现;

还有一个操作是幂等性很难保证，重复秒杀问题，就是当减库存的时候，其实他 不知道之前这个用户有没有减过库存，此时就会再去发送一个消息，告诉他这个用户又对这个商品做了秒杀，那么一般的操作是还要去维护一个分布式的NoSQL的IO方案，访问方案，记录哪些用户已经减过库存了，这也同时加大了成本。<br>

同时这个架构也是一个不适合新手的架构，这个架构网上也会说些解决方案，但是这个解决方案存在着成本性问题， 例如微信的抢红包、淘宝的秒杀，他们有一些产品是用这种方案来去解决；<br>

# 为什么不用Mysql来解决这个问题？
## Mysql真的低效吗？
做测试验证： 同一个id执行update操作减库存；
<br>

>同一个id执行update减库存瓶颈分析：<br>

![同一个id执行update减库存瓶颈分析](907E82AAF519410B8320FF32A386A3E8)
<br>
![压力测试](A65FE5BDCFAF4D8496EFF89E9456C32B)
<br>

>用同一个id进行减库存的测试阐述：<br>
用同一个id进行减库存，有时候竞争的是一条，在这里没有事务控制就是一条条UPDATE执行，他的压力测试什么样呢？<br><br>
一条UPDATE测试可以抗住约4万调QBS, 也就是说同一个商品一秒钟可以被卖4万次，这是一个很高的并发，即使现在卖的最好的秒杀产品，其实也应该达不到这个数字；<br>
那么是什么原因让Mysql低效了呢，如果单单是一条UPDATE, 他的QPS可以抗的很高，而且负载都是一点多，让我们来看下java控制事务的行为分析：
<br>
## java控制事务行为分析
![ava控制事务行为分析](648971BC85D34DA2826C2316D07BE87D)

<br>
图左：update table set num = num -1 where id =10 and num > 0即当库存有货的时候，对库存进行减一操作，执行完之后会进行" insert 购买明细"；<br>
<br>
图中：此时另外一个用户也去进行减库存，此时该用户会有一个block操作，回去执行block行锁，为什么要有行锁呢？<br>
原因：当一个事务开启的时候，另一个事务进来的时候发现他们所用的是同一行，当之前的事务不去提交或回滚的话，那么这个行级锁是不会去释放的 ，这是Mysql及极大多数关系型数据库事务的实现的方案 ；<br>
当" insert 购买明细"执行完之后 会去commit或rollback，此时第二个等待行锁的线程就会获得这个行锁lock，这个时候只有2条，但是如果此时也有很多的用户去减库存，那么就会像图右中那样”等待行锁“—>继续等待，这个就会编程串行话的操作；<br><br>
如果大家更新的是同一个商品的减库存，那么大家都要排队等，直到第一个人去commit/rollback了，然后第二个人再去尝试，这也是一个大量的阻塞操作（串行化了）；

<br>

## 秒杀瓶颈分析
![瓶颈分析](2E2B3359B7BB4107A116CB5EAAB260D3)

<br>

![瓶颈分析2](35A56523F3A743449D80CDACB39CABC8)
<br>

瓶颈分析阐述：<br>
”update减库存“：客户端会执行update, 拿到结果是否更新了，当SQL语句通过网络发送给Mysql的时候，这本身就有网络延迟在里面 ， 这个网络延迟也应该算到上述所述的第二个线程会等这行记录的时间中 （要等update执行完了，并且网络延迟，网络的数据传回来了），他还会继续等，于此同时还会有GC的操作（创建java对象不需要手动的free, 通过jvm的gc自动回收），GC又有新生代GC，老年代GC, 新生代GC会暂停所有的事务代码(java代码)，一般在几十毫秒；<br><br>
”insert购买明细“：也会存在网络延迟、GC, 同时”commit/rollback“；<br>
也就是说如果是java客户端去控制这些事务的话会有什么问题？<br>
会有update减库存、网络延迟、可能的GC（GC不一定每次都出现），再去执行insert，然后 再网络延迟，等待insert语句的返回，也可能会出现GC，最后”commit/rollback“，当这些操作做完之后呢，第二个线程的等待行锁才能有机会拿到这一行的锁 再去执行update减库存；<br><br>

>瓶颈分析总结：<br>
问题的瓶颈点分析出来了，其实不是Msql慢，也不是JAVA慢，可能存在java客户端去执行这些SQL， 等待这些SQL的结果再去做判断，再去执行SQL，这一长串的事务，在java客户端执行，但是java和数据库通信之间会有网络延迟，或者是GC，这些也要加在事务的执行周期里，而同一行的事务是做串行化的，也就是说QPS很好分析了：所有的SQL执行时间 + 网络延迟时间 + 可能的GC，这一行数据就是当前可能执行的时间。<br>
比如说2ms，即1s内只能有500次这样的减库存的秒杀操作，500次对于大部分的系统来说是OK的，但是对于秒杀系统，特别是热点的系统来说是不能满足要求的，特别是排队非常长的时候，性能会呈指数级下降； <br>

优化分析做完之后，得到一个点，行级锁是在commit或rollback之后释放，那么优化的方向： 如何减少行级锁的持有时间，当update 表中的一行数据的时候，一定要快速的commit或rollback，因为其他人还在等，因为这是要给热点的数据；
<br>

## 秒杀优化方向
![优化分析](316D98B815984D15A05CA7C56DCEE09A)

<br>

## 秒杀延迟分析

![延迟分析](63309A9288D44954917BEE62A4EC92AE)

<br>
延迟分析阐述：<br>
延迟的问题是很关键的，上图例举了一个同城机房（上图IP 10.16，10.10这两个IP段是同城机房），当我们用ping的时候，其实他们的网络 延迟是在0.5~2ms的，上图用ping得到他们的网络延迟在0.8~1.02ms之间，不考虑SQL执行时间的情况下，单单考虑网络的一个来回，比如说最高的QPS顶多就是1000 ，若UPDATE之后一般jvm有GC操作，GC操作一般在50ms左右，如果出现GC，特别是系统并发越高，系统垃圾回收机制也就越高，也就意味着锁释放的时间延长50ms;
<br>
<br>

![异地机房网络延迟分析](35B7D1A54B684AB4BBFC35CE2E9FEF49)
<br>
以上是同城机房网络延迟分析阐述，如果是异地机房网络延迟又会怎样呢？<br>

异地机房网络延迟分析阐述：<br>
上图是根据北京-上海之间距离，光在玻璃的传播速度求得的网络一次往返的时间，实际的应该是在20ms左右， 20ms是什么概念呢，如果不巧Java web服务器部署在北京的机房，但是MYSQL部署在上海的机房，那么会出现什么情况呢？
一次SQL光发过去回来，不考虑 SQL的执行时间那么就需要20ms，20ms意味着QPS最高最高也就50 , 因为那条数据被锁住了；
<br>
## 如何判断update更新库存成功？
判断update更新库存成功的两个条件：<br>
1、update自身没报错；
<br>
2、客户端确认Update影响记录数；
<br>
## 秒杀优化思路
把客户端逻辑放到Mysql服务端，避免网络延迟和GC影响；

>优化思路阐述：<br>
java服务器（tomcat）和 MYSQL的来回的交互有网络延迟或GC的干扰，那么可以把这个执行放在在MSYQL的服务器端，之前分析过，单单一条SQL，如果不是客户端控制事务的话，他的效率很高，同一行可以抗几万的QPS，如果是不同行的话可以到几十万的QPS；
<br>
## 如何把客户端的秒杀逻辑放到Mysql服务端
有两种解决方案：<br>
1、定制SQL方案：update /*+[auto_commit] */, 需要修改Mysql源码<br>
2、使用存储过程：整个事务在Mysql端完成；<br>

>使用存储过程的阐释：<br>
存储过程的本质设计出来就是想让一组SQL组成一个事务，然后在服务器端完成 ，而避免客户端去完成事务造成的一个性能的干扰，一般情况下，像Spring声明事务、手动控制事务都是客户端控制事务，这个事务在行级锁没有那么高的竞争情况下是完全OK的，但是秒杀是一个特殊的应用场景，他会在同一行中产生热点，大家都竞争同一行，此时，存储过程就可以发挥作用了 ，存储过程把整个SQL的执行过程完全放在  Mysql 上完成了， Mysql 执行的SQL效率很高，原因：通过主键去执行的查询、更新，这个是我们可以想到的解决方案，本质上也是去优化网络延迟、GC的干扰；
<br>

## 使用存储过程存在的问题
为了性能，把业务逻辑放到数据库的设计实际上是一种偷懒的廉价解决方案，能不这么做就尽量不要。超出了业务边界，数据库的边界是只负责数据操作，不关心任何业务才对。<br>
这样做的最大问题就是随着业务的增加，代码会越来越难以维护了，几年后，更换了几波程序员之后，这段代码就会变成没有人敢碰的代码了。<br>

# 秒杀优化总结
- 前端控制：暴露接口，放置按钮重复；
- 动静态数据分离：CDN缓存，后端缓存；
- 事务竞争优化：减少事务锁时间；


<br>
